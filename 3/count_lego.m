function [NumA, NumB] = count_lego(I)
    I = im2double(I);
    % segment the hsv-converted image
    % https://www.kirupa.com/design/little_about_color_hsv_rgb.htm
    % https://dsp.stackexchange.com/questions/2687/why-do-we-use-the-hsv-colour-space-so-often-in-vision-and-image-processing
    % https://uk.mathworks.com/matlabcentral/fileexchange/28512-simplecolordetectionbyhue--
    % code from functions generated by MATLAB's built-in colour thresholder app
    % thresholds tweaked manually to be adequate across all training images
    [Abw, ~] = createMaskG(I);
    [Bbw, ~] = createMaskY(I);
    % retouch the results and watershed them at the end
    Abw = enhanceSegments(Abw);
    Bbw = enhanceSegments(Bbw);

    % first part of circle detection
    I = rgb2gray(I);
    % https://stackoverflow.com/questions/31433655/find-a-nearly-circular-band-of-bright-pixels-in-this-image
    filt = imfilter(I, fspecial('log', 18, 0.525));
    % only keep the lowest values
    % they highlight the circles on the legos
    Ibin = filt < 0;
    % remove noise and close holes
    Ibin = imopen(Ibin, strel('disk', 2));
    Ibin = imclose(Ibin, strel('disk', 2));
    Ibin = ~bwareaopen(~Ibin, 300);

    % this will sometimes remove more pixel bridges, without damaging the circles
    Ibin = imerode(Ibin, strel('disk', 2));
    Ibin = imdilate(Ibin, strel('disk', 1));
    Ibin = bwareaopen(Ibin, 150);

    % label all regions
    [B, L] = bwboundaries(Ibin);
    figure(1), imagesc(Ibin);

    % https://uk.mathworks.com/matlabcentral/answers/16033-detect-rounding-objects-only-and-remove-all-other-objects
    % https://uk.mathworks.com/help/images/examples/identifying-round-objects.html
    circularityThresh = 0.65;
    stats = regionprops(L, 'Area', 'Centroid');
    keeperList = [];
    % iterate through the regions in the original image
    % only keep those that are round enough
    % loop over the boundaries
    for k = 1:length(B)
      % obtain (X,Y) boundary coordinates corresponding to label 'k'
      boundary = B{k};
      % compute a simple estimate of the object's perimeter
      delta_sq = diff(boundary).^2;
      perimeter = sum(sqrt(sum(delta_sq,2)));
      % obtain the area corresponding to label 'k'
      area = stats(k).Area;
      % compute the roundness metric
      metric = 4*pi*area/perimeter^2;
      if metric > circularityThresh
        keeperList = [keeperList k];
      end
    end
    % only keep round regions
    % https://uk.mathworks.com/matlabcentral/fileexchange/25157-image-segmentation-tutorial
    I = ismember(L, keeperList);

    NumA = countLegos(I, Abw, 3, 8);
    NumB = countLegos(I, Bbw, 1, 4);
end

function [BW,maskedRGBImage] = createMaskG(RGB)
    %createMask  Threshold RGB image using auto-generated code from colorThresholder app.
    %  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
    %  auto-generated code from the colorThresholder app. The colorspace and
    %  range for each channel of the colorspace were set within the app. The
    %  segmentation mask is returned in BW, and a composite of the mask and
    %  original RGB images is returned in maskedRGBImage.
    % Auto-generated by colorThresholder app on 15-Jan-2018
    %------------------------------------------------------

    % Convert RGB image to chosen color space
    I = rgb2hsv(RGB);
    % Define thresholds for channel 1 based on histogram settings
    channel1Min = 0.25;
    channel1Max = 0.525;
    % Define thresholds for channel 2 based on histogram settings
    channel2Min = 0.3;
    channel2Max = 1;
    % Define thresholds for channel 3 based on histogram settings
    channel3Min = 0;
    channel3Max = 0.85;
    % Create mask based on chosen histogram thresholds
    sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
        (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
        (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
    BW = sliderBW;
    % Initialize output masked image based on input image.
    maskedRGBImage = RGB;
    % Set background pixels where BW is false to zero.
    maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
end

function [BW,maskedRGBImage] = createMaskY(RGB)
    %createMask  Threshold RGB image using auto-generated code from colorThresholder app.
    %  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
    %  auto-generated code from the colorThresholder app. The colorspace and
    %  range for each channel of the colorspace were set within the app. The
    %  segmentation mask is returned in BW, and a composite of the mask and
    %  original RGB images is returned in maskedRGBImage.
    % Auto-generated by colorThresholder app on 15-Jan-2018
    %------------------------------------------------------

    % Convert RGB image to chosen color space
    I = rgb2hsv(RGB);
    % Define thresholds for channel 1 based on histogram settings
    channel1Min = 0.085;
    channel1Max = 0.175;
    % Define thresholds for channel 2 based on histogram settings
    channel2Min = 0.5;
    channel2Max = 1.000;
    % Define thresholds for channel 3 based on histogram settings
    channel3Min = 0.3;
    channel3Max = 1;
    % Create mask based on chosen histogram thresholds
    sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
        (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
        (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
    BW = sliderBW;
    % Initialize output masked image based on input image.
    maskedRGBImage = RGB;
    % Set background pixels where BW is false to zero.
    maskedRGBImage(repmat(~BW,[1 1 3])) = 0;
end

function bw = enhanceSegments(bwmask)
    % retouch the segmentation contained in bwmask, a binary image
    % https://uk.mathworks.com/matlabcentral/fileexchange/25157-image-segmentation-tutorial

    smallestAcceptableArea = 750;
	bwmask = bwareaopen(bwmask, smallestAcceptableArea);
	bwmask = imclose(bwmask, strel('disk', 5));
	bwmask = imfill(logical(bwmask), 'holes');
    
    bw = watershedSegment(bwmask);
end

function bw = watershedSegment(bwmask)
    % bwmask = binary image where regions will be split using watershed
    % watershed will separate regions that are joined by small bridges
    % https://uk.mathworks.com/company/newsletters/articles/the-watershed-transform-strategies-for-image-segmentation.html
  
    d = -bwdist(~bwmask);
    mask = imextendedmin(d, 6);
    d2 = imimposemin(d, mask);
    ld2 = watershed(d2);
    bwmask(ld2 == 0) = 0;
    
    bw = imerode(bwmask, strel('disk', 5));
end

function legoCount = countLegos(image, mask, min, max)
    % image = binary image containing circles for all lego blocks
    % mask = regions where lego blocks were detected
    % min = min thresh
    % max = max thresh

    % number each highlighted block
    % also count the blocks
    [labeledMask, blobCount] = bwlabel(mask);
    legoCount = 0;
    for i = 1:blobCount
        % use the highlighted block region to select its circles in image
        searchRegion = image & (labeledMask == i);
        % use bwlabel to count circles in this region
        [~, circleCount] = bwlabel(searchRegion);
        % if the number of circles is ok, count this as a valid lego block
        if circleCount >= min && circleCount <= max && circleCount ~= (min + 2) 
            legoCount = legoCount + 1;
        end
    end
end
